[ 단방향 암호화 ]

1. 단방향 암호화 
평문을 암호화 할 수는 있지만 암호화된 문자를 다시 평문으로 복호화가 불가능한 방식.
주로 해시 알고리즘을 이용하여 단방향 암호화 구현
사용 이유 : 메시지 또는 파일의 무결성(integrity) 보장
저자 서명, 파일 또는 데이터의 식별자, 사용자의 비밀번호, 블록체인 등에 활용
대표적 해시 알고리즘 : MD5, SHA 등

Plan Text(평문) -> SHA -> Ciper TEXT(암호문): 암호화 가능, 복호화 불가능

2. 단방향 암호화의 한계
해시 알고리즘은 동일한 평문에 대해 항상 동일 해시값을 갖는다.
따라서 특정 해시 알고리즘에 대해 특정 평문이 어떤 해시값을 갖는 지 알 수 있다.
-> 해시 함수의 해시 값들을 정리한 테이블(레이보우 테이블)을 이용한 사용자 정보 해킹 공격(레인보우 공격)
또한 해시 함수는 본래 데이터를 빠르게 검색하기 위해 탄생.
-> 빠른 처리 속도는 공격자에게 장점, 바른 속도로 임의의 문자열 해시값과 대상 해시값을 비교해 공격

3. 솔팅(Salting) & 키 스트레칭(Key Stretching)
솔팅(Salting)
솔팅은 단방향 해시로 암호화를 진행할 시, 본래 데이터에 추가 랜덤 데이터를 더해 암호화를 진행하는 방식
추가 데이터가 포함 되었기 때문에 원래 데이터의 해시값에서 달라짐
키 스트레칭(Key Stretching)
단방향 해시값을 계산 한 후 그 해시값을 해시하고 또 이를 반복하는 방식
1초에 50억 개 이상 비교할 수 있던 것을 키 스트레칭 적용한 경우 1초에 5번 가량 비교 가능


[ 양방향 암호화 - 대칭키 ]

1. 대칭키 암호화
양방향 암호화는 암호화된 값을 암호화 하기 이전 값으로 복호화 할 수 있음
암호화 진행 시 사용하는 키와 암호문으로부터 평문을 복호화 할 때 사용하는 키가 동일
암호화 진행할 때 사용한 키를 모른다면 해당 암호문은 다시 복호화 할 수 없음
대표적 대칭키 양방향 알고리즘 : AES 

Plan Text(평문) -> AES +(Secret Key) -> Ciper TEXT(암호문): 암호화, 복호화 가능

2. 대칭키 암호화 한계
대칭키 방식은 하나의 키를 이용하므로 다른 사람과 대칭키 기반으로 암호화 통신을 할 경우 상대방도 사전에 같은 키를 갖고 있어야 함
하지만 키를 주고 받는 과정에서 키가 유출될 우려, 암호화 토신 해킹 문제, 또한 여러 상대방과 통신할 경우 각각의 키를 관리 어려워짐


[ 양방향 암호화 - 비대칭키 ]

1. 비대칭키 암호화
암호화와 복호화 모두 가능, 암호화를 진행할 때 키 이용
비대칭키는 암호화에서 사용하는 키와 복호화 할 때 사용하는 키를 다르게 사용
public key와 private key 존재. 이 두 개의 키를 key pair이라 부름
대칭키의 고질적 문제였던 키의 탈취 또는 관리의 단점 보완

Plan Text(평문) -> (public key) + RSA +(private key) -> Ciper TEXT(암호문): 암호화, 복호화 가능

2. 데이터 암호화
사용자가 서버에 비대칭키 방식으로 데이터를 보내는 과정
- 서버에 key pair 발급 -> public key 사용자에게 전달
- 사용자는 데이터를 암호화 할 때 서버에서 받은 public key 사용
- 서버는 사용자가 보낸 암호화된 데이터를 private key로 복호화해 내용 확인
전자서명 : 비대칭키 암호화를 통해 구현, key pair가 종이문서의 인감도장과 인감증명 역할


[ Bcrypt ]

1. Salting & Key Stretching
단방향 암호화에 사용되는 해시 알고리즘은 동일한 평문에 대해 항상 동일 해시값을 가짐
특정 해시 알고리즘에 대해 특정 평문이 어떤 해시값을 갖는지 알 수 있음

해시 함수는 본래 신속히 데이터를 검색하기 위해 탄생 
-> 문제 보완하기 위해 단방향 암호화 진행 시 솔팅과 키 스트레칭을 적용 시킴

솔팅 - 단방향 해시 함수 암호화를 진행 할 때 본래 데이터에 추가적으로 랜덤한 데이터를 더하는 방식
키 스트레칭 - 단방향 해쉬값을 계산 한 후, 그 해쉬값을 또 다시 해시하고 이를 반복하는 방식

2. Bcrypt
키(key) 방식의 대칭형 블록 암호에 기반을 둔 암호화 해시함수
레인보우 테이블 공격을 방지하기 위해 솔팅과 키 스트레칭을 적용한 대표적 예

Bcrypt는 단방향 해시 알고리즘, 복호화 불가능, 검증은 암호화된 값이 가지고 있는 알고리즘
비교하고 싶은 평문을 
암호화된 값이 가지고 있는 알고리즘. Cost Factor, Salt을 이용해 해시를 진행한 후
암호화된 값과의 비교를 통해 검증을 진행

비밀번호를 관리할 때 유용하게 쓰임 
- DB에 암호화되어 저장된 비밀번호를 복호화 불가능, 내부자가 회원의 비밀번호를 알아내는 것 불가능
- 회원이 입력한 비밀번호와 일치하는지만 확인 가능

Hashing: 원본의 의미를 알 수 없게 섞어 놓는 것
Salting: 실제 비밀번호에 랜덤 값을 더해 해시값을 계산하는 방법
Key Stretching: 해쉬 값을 여러번 반복해서 해시 하는 행위

    { 암호화 }

pip install bcrtpy
pip install pyjwt # jwt(json web token)를 암호화, 복호화 해주는 라이브러리 설치

import bcrypt
password = '암호화 대상' # str 형식의 암호화 대상
password.encode('utf8') # 암호화 함수는 오직 bytes string에서만 작동, 해싱하기 전에 변환
pw(암호 인코드) = bcrypt.hashpw(password.encode('utf8), bcrypt.gensalt())
pw2(비교 암호) = '비교 대상 암호'
bcrypt.checkpw(pw2.encode(utf8), pw)

    { 토큰 발행 } 

사용자가 ID, PASSWORD를 입력해 로그인 버튼을 누르면 
서버는 ID와 PASSWORD를 DB에 저장된 것과 비교하고
인증이 완료되면, 회원에게 토큰 발행
토큰은 사용자 브라우저의 쿠키나 세션스토리지에 저장
서버에 데이터를 요청할 때 마다 토큰을 담아서 정보를 요청
서버는 해당 토큰을 검증한 뒤 데이터를 전송

 [ jwt ]

import jwt
jwt.encode({'user_id' : 1}, 'Secret Key', algorithm='HS256')


토큰 대상, 시크릿 키, 해싱 알고리즘을 차례대로 입력
토큰 방식도 토큰이 탈취당할 경우 정보 보안에 타격을 입음
-> 보완 방식 : refresh token

HTTP 요청
HTTP 통신 방식 : 응답 후 연결이 끊기게 되며 과거에 대한 정보를 전혀 담지 않음
각각의 HTTP 요청에는 주체가 누구인지에 대한 정보가 필수적(인증이 필요없다면 상관X)
# 보안에 취약함

JWT: Json Web Token 인증에 필요한 정보들을 암호화 시킨 토큰
Access Token(JWT 토큰)을 HTTP 헤더에 실어 서버로 보냄
Header: 정보를 암호화할 방식, 타입 등
Payload: 서버에서 보낼 데이터 들어감, 유저의 고유 ID 값, 유효기간 등
Verify Signature: Base64 방식으로 인코딩한 Header, payload 그리고 Secret Key를 더한 후 서명

JWT 토큰 인증 과정
1. 사용자 로그인
2. 서버에서 계정정보를 읽어 사용자를 확인 후, 사용자 고유한 ID값을 부여한 후, 기타 정보와 함께 Payload에 넣음
3. Access Token 발급: JWT 토큰의 유효기간을 설정
4. 암호화할 Secret Key를 이용해 Access Token을 발급
5. 사용자는 Access Token을 받아 저장한 후, 인증이 필요한 요청마다 토큰을 헤더에 실어 보냄.
6. 서버에서 해당 토큰의 Verify Signature를 Secret Key로 복호화한 후, 조작 여부, 유효기간 확인
7. 검증이 완료되면, Payload를 디코딩하여 사용자의 ID에 맞는 데이터를 가져옴

세션 쿠키 방식과 가장 큰 차이점
세션/ 쿠키: 세션 저장소에 유저의 정보를 넣음
JWT: 토큰 안에 유저의 정보들을 넣음
HTTP 헤더에 세션 ID나 토큰을 실어서 보내준다는 점은 동일,
서버 측에서는 인증을 위해 암호화를 하냐, 별도의 저장소를 이용하냐의 차이 발생 

JWT 장점
1. 간편, 추가 저장소가 필요 없음, Stateless 한 서버를 만드는 입장에서 강점
Stateless(어떠한 별도의 저장소도 사용하지 않는, 상태를 저장하지 않는 것)
서버 확장, 유지, 보수에 유리
2. 확장성이 뛰어남, 토큰 기반으로 하는 다른 인증 시스템에 접근이 가능함

JWT 단점
1. 이미 발급된 JWT에 대해 돌이킬 수 없음
유효기간이 완료될 때 까지 계속 사용 가능, 악의적 사용자 문제
2. Payload 정보가 제한적, 따로 암호화되지 않기 때문에 디코딩하면 누구나 정보를 확인할 수 있다.
3. JWT의 길이가 길어 인증이 필요한 요청이 많아질수록 서버의 자원낭비 발생

https://tansfil.tistory.com/58

